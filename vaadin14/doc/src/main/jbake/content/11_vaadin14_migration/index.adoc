:jbake-title: Vaadin 14 Migration
:jbake-type: chapter
:jbake-status: published
:jbake-order: 1000

:source-dir-v8: ../../../../../../vaadin8/samples/test-playground/src/main/java/org/linkki/samples/playground/
:source-dir-v14: ../../../../../../vaadin14/samples/test-playground/src/main/java/org/linkki/samples/playground/


== Vaadin 14 Migration

=== Application Framework

==== Messages
* Deprecated `Message*` classes have been removed
** `MessageListPanel` has been replaced by `MessageUiComponents#createMessageTable`
** `MessagePmo` has been replaced by `MessageRowPmo`
** `MessageRow` has been replaced by `MessageUiComponents#createMessageComponent`

==== LinkkiUi and navigation
////
https://jira.faktorzehn.de/browse/LIN-2042
https://jira.faktorzehn.de/browse/LIN-2488
https://jira.faktorzehn.de/browse/LIN-2523
////

Navigation has been replaced by https://vaadin.com/docs/v14/flow/routing/tutorial-routing-annotation[Routing], using the `@Route` annotation at the corresponding `Component` itself. With the new changes, it is no longer necessary to extend the UI as the tasks of `LinkkiUi` either became oblivious or is overtaken by `ApplicationLayout`.

[[vaadin14-migration-linkkiUi]]
LinkkiUi::
+
|=== 
| Change | Migration

| The class `LinkkiUi` is removed.
| Remove sub-classes of `LinkkiUi`.
|===

[[vaadin14-migration-applicationLayout]]
ApplicationLayout::
+
[cols="a,a"]
|===
| Change | Migration

| * The constructor now takes `ApplicationConfig` as a parameter.
  * #getApplicationConfig` has been removed.
| * Create a new sub-class of `ApplicationLayout` (e.g. `MyApplicationLayout`) 
  * In the new subclass, pass an instance of the customized `ApplicationConfig` to the super constructor. This `ApplicationConfig` was previously used in the implementation of <<vaadin14-migration-linkkiUi, `LinkkiUi`>>.

| `#createApplicationNavigator` has been removed.
| No migration needed
|===
NOTE: `ApplicationLayout` itself implements `RouterLayout` which make it possible to use the `ApplicationLayout` as the layout for routes, previously known as views.

ApplicationConfig::
+
[cols="a,a"]
|===
| Change | Migration

| The class is moved from `org.linkki.framework.state` to `org.linkki.framework.ui.application`.
| Reorganize import in the project where `ApplicationConfig` is used.

|`ApplicationConfig#createApplicationLayout` has been removed. 
| Move the implementation of `#createApplicationLayout` to the implementation of <<vaadin14-migration-applicationLayout, `ApplicationLayout`>>.

| Name, version, description and copyright are moved to `ApplicationInfo`.
| * Create a new implementation of `ApplicationInfo` that contains the existing implementation for name, version, description and copyright. +
If additional information needs to be stored to be displayed in the header and footer, follow the migration steps for the <<vaadin14-migration-applicationHeader, `ApplicationHeader`>> and  the <<vaadin14-migration-applicationFooter, `ApplicationFooter`>>.
  * Return a instance of the new implementation in `ApplicationConfig#getApplicationInfo.

| The return type `ApplicationHeaderDefinition` of `ApplicationConfig#ApplicationHeaderDefinition` has changed:

  * Until now: creates a `ApplicationHeader` from an `ApplicationMenu`
  * New: creates an `ApplicationHeader` from an `ApplicationInfo` and a sequence of  `ApplicationMenuItemDefinitions`.
| * If `getHeaderDefinition` was not overridden, no migration is needed.
  * If a custom implementation of `ApplicationHeader` was used, consult migration steps of the <<vaadin14-migration-applicationHeader, `ApplicationHeader`>>.

| `ApplicationConfig#ApplicationFooterDefinition` has changed:
  * Until now: creates a `ApplicationFooter` from an `ApplicationConfig`
  * New: creates an `ApplicationFooter` from an `ApplicationInfo`
| * If `getFooterDefinition` was not overridden, no migration is needed.
  * If a custom implementation of `ApplicationFooter` was used, consult migration steps of the <<vaadin14-migration-applicationFooter, `ApplicationFooter`>>.
|===

[[vaadin14-migration-applicationHeader]]
ApplicationHeader::
If no custom implementation of `ApplicationHeader` is used, no migration is needed. +
In custom implementations:
+
[cols="a,a"]
|===
| Change | Migration

| `ApplicationHeader#addUserMenu` The user menu has been completely removed. This has to be implemented by yourself. 
| If you want to create a user menu, then overwrite `ApplicationHeader#createRightMenuBar` and add a `MenuItem` to the `MenuBar`

| `ApplicationHeader` uses an `ApplicationInfo` and `Sequence<ApplicationMenuItem>` as arguments instead of `ApplicationMenu`.
| Adjust the constructor and the super constructor call within with the new parameters.

|`ApplicationHeader` now extends `Composite<HorizontalLayout>` instead of `HorizontalLayout` directly.
| Whenever components are added, add the components to `getContent()` instead.

|`ApplicationInfoPmo` uses `ApplicationInfo` as constructor argument instead of `ApplicationConfig` 
| In a custom `ApplicationInfoPmo` implementation is used:

* In subclasses of `ApplicationInfoPmo`, adjust the constructor and the super constructor call within with the new parameters.
* If `ApplicationHeader#getApplicationInfo`, change the return type to the custom subclass.
* In `ApplicationHeader#createApplicationInfoPmo`, use the adjusted constructor with `#getApplicationInfo`.

|  `ApplicationHeader#addRightComponents()` visibility has changed from `protected` to `private` due to deprecation.
| In the subclasses, override and move the code to `addRightComponents(HorizontalLayout)`.

| API of `ApplicationMenuItemDefinition` has changed, resulting in changes in `getMenuItemDefinitions`.
| See migration steps of the <<vaadin14-migration-applicationMenuItemDefinition, ApplicationMenuItemDefinition>>.
|===

[[vaadin14-migration-applicationMenuItemDefinition]]
ApplicationMenuItemDefinition::
+
The API of `ApplicationMenuItemDefinition` is completely reworked. Instead of extending the class for customization, the new API is intended to be easily composable for customization.
+
[cols="a,a"]
|===
| Change | Migration

| Argument `position` is removed from the constructor as it was not necessary.
| Remove the attribute. To ensure the position of the menu item, make sure to put it at the right position in `ApplicationConfig#getMenuItemDefinitions`.

| `getName` is removed.
| Pass the name to the constructor directly instead.

| The methods `createItem` and `internalCreateItem` are removed. Instead, new constructors are introduced: 

* with name and a `Handler` that is executed on click. 
* with name and a list of `ApplicationMenuItemDefinitions` as sub-menu items
* with name and a URL String to navigate to on click. This method handles both external and internal links.
* with name and a `Class` to navigate to. The given class should be a <<vaadin14-migration-views, route component>>. 
| Use the existing implementation of `internalCreateItem` and `createItem` to directly create new instances of `ApplicationMenuItemDefinition`. A few examples are provided below.
|===
+
The following code snippet shows a simple `ApplicationMenuItem` before and after migration:
+
.Migration of a simple ApplicationMenuItem
[cols="a,a"]
|===
| Before migration | After migration

| 
[source,java]
----
include::{source-dir-v8}application/custom/CustomApplicationConfig.java[tags=applicationMenuItemDefinition]
----
|
[source,java]
----
include::{source-dir-v14}application/custom/CustomApplicationConfig.java[tags=applicationMenuItemDefinition]
----
|===
+
For more complex menu items that used to extend from `ApplicationMenuItem`, consider create menu item definitions directly instead of inheriting. If the implementation need to be customizable, it can be easily done by composing `ApplicationMenuItems`. +
Here is an example of a more complex `ApplicationMenuItem`. This menu item contains one sub-menu item with caption "New". If only one sub-sub-menu item is given, the sub-menu-item shows a notification on click (caption -> New). If multiple sub-sub-menu items are given, those are shown in the sub-menu item (caption -> New -> sub-sub-menu items).
+
.Migration of a complex ApplicationMenuItem
[cols="a,a"]
|===
| Before migration | After migration

| 
[source,java]
----
include::{source-dir-v8}application/custom/CustomMenuItemDefinition.java[tags=class]
----
|
[source,java]
----
include::{source-dir-v14}application/custom/CustomMenuItemDefinitionCreator.java[tags=class]
----
|===

[[vaadin14-migration-applicationFooter]]
ApplicationFooter::
If no custom implementation of `ApplicationFooter` is used, no migration is needed. +
In custom implementations:
+
[cols="a,a"]
|===
| Change | Migration

| `ApplicationFooter` uses an `ApplicationInfo` as argument instead of `ApplicationConfig`.
| Adjust the constructor and the super constructor call within with the new parameters.

|`ApplicationFooter` now extends `Composite<HorizontalLayout>` instead of `HorizontalLayout` directly.
| Whenever components are added, add the components to `getContent()` instead.

| `ApplicationFooter#buildText` uses `ApplicationInfo` as argument instead of `ApplicationConfig`.
| Adjust the implementation of `#buildText` to use the given `ApplicationInfo`. If a custom `ApplicationInfo` is used, the argument may need to be casted to the custom class. 

| `ApplicationHeader#addRightComponents()` visibility has changed from `protected` to `private` due to deprecation.
| In subclasses, override and move the code to `addRightComponents(HorizontalLayout)`.

| Visibility of `ApplicationFooter#init` is reduced to protected.
| This method should not be called externally anymore. Remove external calls.
|===

[[vaadin14-migration-views]]
Views::
//TODO FIPM-4214
[cols="a,a"]
|===
|Change | Migration

| `View` interface is no longer necessary.
| Remove the interface in all implementations.

| Views must be annotated with `@Route`.
| Annotate all views with `@Route`. If the view was previously annotated with `CDIView` or `@SpringView`, you may now need to specify the route explicitly.
//TODO FIPM-4214 ViewScoped
|===

Other changes::
* `ApplicationNavigator` has been removed

=== Components

* linkki dialogs are now extending `Composite<Dialog>` instead of `Window`.
* `MessageUiComponents` are now displayed using `Grid` instead of `Table`

==== TabSheetArea has been replaced by LinkkiTabLayout
////
https://jira.faktorzehn.de/browse/LIN-2158
////

* `TabSheetArea#addTab` -> `LinkkiTabLayout#addTabSheet`
* `TabSheetArea#createContent` to add tabs using `TabSheetArea#addTab` has been removed. Instead, `LinkkiTabLayout#addTabSheet` should be used
* `TabSheetArea#updateContent` has been removed.

===== SidebarLayout has been replaced by LinkkiTabLayout

[source,java]
----
-- Vaadin 8
SidebarLayout sidebarLayout = new SidebarLayout();
-- Vaadin 14
LinkkiTabLayout linkkiTabLayout = LinkkiTabLayout.newSidebarLayout();
----

* `SidebarLayout#addSheet` -> `LinkkiTabLayout#addTabSheet`
* `SidebarLayout#addSheets` -> `LinkkiTabLayout#addTabSheets`
* `SidebarLayout#addSelectionListener` -> `LinkkiTabLayout#addSelectedChangeListener`
* `SidebarLayout#select(id)` -> `LinkkiTabLayout#setSelectedTabSheet(sheet.getId())`
* `SidebarLayout#select(sheet)` -> `LinkkiTabLayout#setSelectedTabSheet(sheet.getId())`
* `SidebarLayout#getSelected` -> `LinkkiTabLayout#getSelectedTabSheet`
* `SidebarLayout#getSidebarSheet(id)` -> `LinkkiTabLayout#getTabSheet(id)`
* `SidebarLayout#getSidebarSheets` -> `LinkkiTabLayout# getTabSheets`
* `SidebarSelectionEvent#getOldValue` -> `SelectedChangeEvent#getPreviousTab`
* `SidebarSelectionEvent#getSelectedSheet` -> `SelectedChangeEvent#getSelectedTab`

Tab visibility can be controlled using `LinkkiTabSheetBuilder#visibleWhen` and `LinkkiTabLayout#updateSheetVisibility`.

===== SidebarSheet has been replaced by LinkkiTabSheet

For performance reasons, components must be created via a supplier and can no longer be set directly.

[source,java]
----
-- Vaadin 8
SidebarSheet sidebarSheet = SidebarSheet(id, icon, name, contentSupplier, uiUpdateObserver);
-- Vaadin 14
LinkkiTabSheet linkkiTabSheet = LinkkiTabSheet.builder(id)
				.caption(icon.create()) //.caption(String)
				.description(name)
				.content(contentSupplier)
				.onSelectHandler(uiUpdateObserver)
				.build();
----

* `SidebarSheet#getButton().getIcon()` -> `LinkkiTabSheet#getTab().getChildren().findFirst().get()`
* `SidebarSheet#getName` -> `LinkkiTabSheet#getDescription`

==== @UIButton
////
https://jira.faktorzehn.de/browse/LIN-2142
////
* `styleNames()` has been replaced by `variants()`, which now returns an Array of `ButtonVariant`
* `shortcutKeyCode` now returns `String[]`. Commonly used `KeyCodes` in linkki are defined in `KeyCode`. An overview of all supported keys can be found in Vaadin's `Key` class. 
* `shortcutModifierKeys` now returns an Array of `KeyModifier`. For a list of available modifiers, see Vaadin's enum class `KeyModifier`.

==== @UIDateField
////
https://jira.faktorzehn.de/browse/LIN-2044
https://jira.faktorzehn.de/browse/LIN-2091
////
The date format of a @UIDateField is now controlled by `DateFormats` and the locale, the attribute `dateFormat` has been removed.

==== @UITextArea
////
https://jira.faktorzehn.de/browse/LIN-2059
////
Attribute `rows` does not exists anymore. It has been replaced by `height`, which returns a `String`, specifying the height of the component using a number and a CSS unit, for example "5em".

==== @UILabel
////
https://jira.faktorzehn.de/browse/LIN-2053
////
The usage of the `ContentMode` for `@UILabel` in Vaadin 8 has changed. Instead of setting `Label#setContentMode` to `true` when using `Label#htmlContent` , you can use `getElement().setProperty("innerHTML", "<b>My html content</b>")` of the corresponding component, as now used in linkki `LabelValueAspectDefinition`.

For a further example, see https://vaadin.com/forum/thread/17133860/label-contentmode-html

==== ComponentFactory
////
https://jira.faktorzehn.de/browse/LIN-2053
////
Following `*Label` methods have been removed, as `Label` has been replaced by `LinkkiText`:

* `newLabelWidth100(parent, caption)`
* `sizedLabel(parent, caption, contentMode)`
* `sizedLabel(parent, caption)`
* `newLabelWidthUndefined(parent, caption)`
* `labelIcon(parent, fontIcon)`
* `newEmptyLabel(layout)`
* `newLabelIcon(fontIcon)`
* `newLabelFullWidth(caption, contentMode)`
* `newLabelFullWidth(caption)`
* `newLabelUndefinedWidth(caption, contentMode)`
* `newLabelUndefinedWidth(caption)`

==== Component#setIcon
The `setIcon` method for `Component` has been deleted. It is only available for `@UIButton` and components, that are implementing the `HasIcon` interface, like the ones created by `@UILabel` and `@UILink`.

==== Resource / Icon
`com.vaadin.server.Resource` for icons in Vaadin 8 has been replaced by `VaadinIcon#create`

==== Tables have been replaced by Grids
////
https://jira.faktorzehn.de/browse/LIN-2088
////
In Vaadin 14, `Table` has been replaced by `Grid`

* `PmoBasedTablefactory` has been replaced by `GridComponentCreator`
* `@UITableColumn`: `expandRatio` replaced by `flexGrow`. The `flexGrow` specifies what amount of the available space inside the table the column should take up and grow (if resized), proportionally to the other columns. If `flexGrow` is set to 0, the column has a fixed `width`.

=== Aspect annotations

==== @BindIcon
The `@BindIcon` annotation is available for `@UIButton` and all components, that are implementing the `HasIcon` interface. At the moment, these are `@UILabel` and `@UILink`. Using `htmlContent` of the `@UILabel` will override any icon.

=== NLS

==== TextProvider
////
https://jira.faktorzehn.de/browse/LIN-2123
////
It is recommended to provide an implementation of `I18NProvider` as following, to ensure `UI#getLocale` returns the best matching `Locale` corresponding to the user agent's preferences (i.e. the `Accept-Language` header). If no `I18NProvider` is available, the default JVM `Locale` is used.

[source,java]
----
@Component
public class MyI18NProvider implements I18NProvider {
	...
}
----

=== Styling
////
https://jira.faktorzehn.de/browse/LIN-2249
////
==== Theming
Valo theme has been replaced by Lumo theme. For more information see https://vaadin.com/docs/flow/migration/6-theming.html

==== Tooltips
////
https://jira.faktorzehn.de/browse/LIN-2054
////
By now, tooltips are only supported by `LinkkiTabSheet`, using the `LinkkiTabSheet#description` property. Other UI components currently do not support tooltips. For more information see https://vaadin.com/forum/thread/17094165/tooltips

==== Notifications
////
https://jira.faktorzehn.de/browse/FIPM-4131
////
See <<notifications, Notifications>>

==== ComponentStyles

In Vaadin 8, sections created with `@UISection` have a dynamic label width by default, i.e. the labels are as long as the longest label.
For `@UIFormSection`, `LinkkiTheme` offered style names to set a fixed width.

This behavior has changed with Vaadin 14. All sections now have a fixed label width by default. It is not possible to have dynamic label width anymore.
To set a custom label width, you can use `ComponentStyles.setFormItemLabelWidth(Component, String)`. 
This replaces the class names `LinkkiTheme.LABEL_FIXED_WIDTH` and `LinkkiTheme.LABEL_FIXED_WIDTH_LONG`.

.Migration of a page with longer fixed width
[cols="a,a"]
|===
| Before migration | After migration

| 
[source,java]
----
public class MyPage extends AbstractPAge {
    @Override
    public final void createContent() {
       ...
       addStyleName(LinkkiTheme.LABEL_FIXED_WIDTH_LONG);
    }
    ...
}
----
|
[source,java]
----
public class MyPage extends AbstractPAge {
    @Override
    public final void createContent() {
       ...
       ComponentStyles.setFormItemLabelWidth(this, "12em");
    }
    ...
}
----
|===

To apply a custom label width to all sections inside a `Component`, the surrounding layout such as `AbstractPage` can be passed as the `Component`-Parameter.

For more information see <<component-styles, ComponentStyles>>.