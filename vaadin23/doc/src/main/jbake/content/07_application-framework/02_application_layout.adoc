:jbake-title: Application Layout
:jbake-type: section
:jbake-status: published

:image-dir: {images}07_application-framework
:source-dir: ../../../../../../vaadin23/samples/test-playground/src/main/java

=== ApplicationLayout

When using *linkki Application Framework*, all views should be displayed in a customized `ApplicationLayout` which provides the application frame. Therefore, the first step to use application framework is to create a subclass of `ApplicationLayout`.

The main purpose of this class is to hold the custom implementation of <<application-config, ApplicationConfig>> in which the application frame is configured. This custom implementation can be passed to the super constructor. The implementation of `ApplicationLayout` itself should have a default constructor which makes it usable as a https://vaadin.com/docs/latest/flow/routing/layout[RouterLayout].

.Example ApplicationLayout
[source,java]
----
include::{source-dir}/org/linkki/samples/playground/ui/PlaygroundAppLayout.java[tags=app-layout]
----

The `ApplicationLayout` surrounds the view with an <<application-header,`ApplicationHeader`>> and an optional `ApplicationFooter`.

The header is designed to have multiple menu actions on the left and may have some specific items like help menu or preferences on the right side. 

The footer is hidden by default and can simply contain some application info.

Between `ApplicationHeader` and `ApplicationFooter` is the main area that displays the current view.

[[application-config]]
==== Application Configuration

The main aspects of the application are configured using the `ApplicationConfig`. This interface needs to be implemented once in every *linkki* application and provided to the `ApplicationLayout`. 

[[application-info]]
===== ApplicationInfo

`ApplicationConfig` refers to an `ApplicationInfo`, which defines basic information about the application, such as name and copyright. Furthermore, parts of an `ApplicationLayout` are configured by the `ApplicationConfig`, such as the header, footer, as well as converters that should be used to convert values between UI and the underlying model.

[[application-header]]
===== Application Header

`ApplicationConfig#getApplicationHeader` configures the application header. An `ApplicationHeader` consists of two menu bars: one on the left, and one on the right. 

The menu actions on the left are directly defined in the Application Configuration by the method <<application-menu-item-definition, getMenuItemDefinitions>>. 

The menu bar on the right contains a help menu by default. In the help menu, a sub menu item displays the <<application-info, ApplicationInfo>> in a dialog. The right menu can be customized as follows:

. Create a custom subclass of `ApplicationHeader`
. In the subclass:
 * To customize items of the help menu, override `addHelpMenuItems`
 * To customize items of the menu bar, override `createRightMenuBar`
. Use the custom subclass in `ApplicationConfig#getHeaderDefinition`

[TIP]
====
The right menu and its items have the following IDs by default:

|===
| `appmenu-right` | the right menu bar
| `appmenu-help` | the help menu within the right menu bar
| `appmenu-info` | the info submenu within the help menu
|===

As HTML IDs are very convenient for UI testing, custom items added to the menu should also set an ID. 
====

[TIP]
====
The class <<application-menu-item-definition, ApplicationMenuItemDefinition>> can be used to create items for the right menu.
====

[[application-menu-item-definition]]
===== ApplicationMenuItemDefinition

`MenuItems` can be added to the `ApplicationHeader` using `ApplicationMenuItemDefinition`.

For creation, `ApplicationMenuItemDefinition` provides following constructors:

* `ApplicationMenuItemDefinition(String, String, Handler)`: Name and ID of the menu and a `Handler` that is executed on click. 
* `ApplicationMenuItemDefinition(String, String, List<ApplicationMenuItemDefinition>)`: Name and ID of the menu and a list of `ApplicationMenuItemDefinitions` as sub-menu items. Sub-menus are added in order as defined in the sub-menu list.
* `ApplicationMenuItemDefinition(String, String, String)`: Name and ID of the menu and a URL as String to navigate to on click. This method handles both external and internal links.
* `ApplicationMenuItemDefinition(String, String, Class<? extends Component>)`: Name and ID of the menu and a `Class` to navigate to. The given class should be a <<vaadin23-migration-views, route component>>.

[[anchor-appmenu-id]]
TIP: The ID of the menu item is used as ID of the HTML element in the DOM. This makes it easier to navigate through the menu in UI tests. +
The old versions of these constructors without an parameter for the ID have been deprecated. If they are still used the ID of the menu is derived from the name and converted to an appropriate format with the prefix `appmenu-`.

More complex menu items can be implemented by creating menu item definitions directly instead of inheriting. If the implementation needs to be customizable, it can be easily done by composing `ApplicationMenuItems`.

The following example uses a factory class to create the menu. A menu item contains one sub-menu item with caption "New". If only one sub-sub-menu item is given, the sub-menu-item shows a notification on click (caption -> New). If multiple sub-sub-menu items are given, those are shown in the sub-menu item (caption -> New -> sub-sub-menu items). This can be used in `ApplicationConfig#getMenuItemDefinitions()`

.CustomMenuItemDefinitionCreator
[source,java]
----
include::{source-dir}/org/linkki/samples/playground/application/custom/CustomMenuItemDefinitionCreator.java[tags=class]
----

To add a `MenuItem` when to your own `ApplicationMenu` or `SubMenu` the following methods can be used:

* `createItem(ApplicationMenu)`: Creates and adds a `MenuItem` to the given `ApplicationMenu`. 
* `createItem(SubMenu)`: Creates and adds a `MenuItem` to the given `SubMenu`.

.ApplicationMenu
[source,java]
----
ApplicationMenuItemDefinition startMenuItemDefinition = new ApplicationMenuItemDefinition("Start", () -> goToStart());
ApplicationMenu menuBar = new ApplicationMenu();

startMenuItemDefinition.createItem(menuBar);
----

.SubMenu
[source,java]
----
ApplicationMenuItemDefinition itemDefinition = new ApplicationMenuItemDefinition("Start", () -> goToStart());
-- new MenuBar to create item for sub-menu
MenuBar menuBar = new MenuBar();
SubMenu subMenu = menuBar.addItem("item").getSubMenu();

itemDefinition.createItem(subMenu);
----

[[sidebarlayout]]
=== LinkkiTabLayout

The `LinkkiTabLayout` is a UI component that gives access to several different views.

image::{image-dir}/sidebar-layout.png[]

On the left there is a vertical bar containing icons (buttons) for every sheet. The tooltip of the button displays the name of the corresponding sheet. The content of the selected sheet is displayed to the right of the bar.

In order to create a sidebar instantiate the `LinkkiTabLayout` and add `LinkkiTabSheets` that can be built using a builder. Every sheet requires an icon, a name and a content supplier (`Supplier<Component>`). The supplier is called when the sheet is selected for the first time (lazy initialization). This approach only creates the content if it is requested by the user. It also spreads out the component creation, avoiding long loading times at the start.

[source,java]
----
include::{source-dir}/org/linkki/samples/playground/application/SampleView.java[tags=sidebar-addSheet]
----

[[aftertabselectedobserver]]
Additionally the tab component can implement `AfterTabSelectedObserver`. Its method `afterTabSelected(TabSheetSelectionChangeEvent)` is called every time the sheet is selected, that means it gets visible. Use this observer to update your binding context in case of changes to the underlying model while the sheet was not selected. 

.Using `AfterTabSelectedObserver`
[source,java]
----
include::{source-dir}/org/linkki/samples/playground/application/ReportListPage.java[tags=implementAfterTabSelectedObserver]

include::{source-dir}/org/linkki/samples/playground/application/ReportListPage.java[tags=afterTabSelected]
----

When adding a PMO as tab component with `VaadinUiCreator#createComponent(Object, BindingContext)` to `LinkkiTabSheet`, use `LinkkiTabSheet#addTabSelectionChangeListener(ComponentEventListener)` to add additional listeners afterwards.

=== Headline

For every sheet it is useful to have a headline that describes the current content. It natively has a headline caption and could be extended by subclasses.


image::{image-dir}/create-report-simple.png[]


To use a `Headline` simply instantiate and add the component to your content.

If you want the Headline's title to be updated dynamically, you can also bind it to a PMO. To do so, create a PMO containing a corresponding getter method for `Headline#HEADER_TITLE`:

[source,java]
----
include::{source-dir}/org/linkki/samples/playground/application/HeadlinePmo.java[tags=HeadlinePmo]
----

Then bind it with the headline:

[source,java]
----
include::{source-dir}/org/linkki/samples/playground/application/ReportListPage.java[tags=bind-headline]
----

[[error-handler]]
=== ErrorHandler

In case of an unhandled runtime exception, *linkki* shows information about the occurred error such as timestamp, a short description and a detailed stacktrace in a dialog. After confirming the dialog, the user is redirected to either the default main URL, or a custom error URL that can be set by extending the `DialogErrorHandler` and pass it to the `super`-constructor.

.DialogErrorHandler
[source,java]
----
public class DialogErrorHandler implements ErrorHandler {
    public DialogErrorHandler(BiFunction<ErrorEvent, Handler, ConfirmationDialog> dialogCreator, String startView) {
        this.dialogCreator = dialogCreator;
        this.startView = startView;
    }
    
    @Override
    public void error(ErrorEvent event) {
        ConfirmationDialog dialog = dialogCreator.apply(errorEvent, () -> UI.getCurrent().navigate(startView, QueryParameters.fromString("errorOccurred")));
        dialog.open();
    }
}
----

In addition, `ApplicationLayout#getErrorHandler()` must be overridden to return your custom `ErrorHandler`.

When redirecting, an additional `errorOccurred` query parameter is added to the URL. This parameter enables the target view to react to the error. It can be useful in some cases to enable or disable certain features in `BeforeLeaveHandler#beforeLeave(BeforeLeaveEvent)` in case of an error. 
For more information refer to https://vaadin.com/docs/latest/flow/routing/lifecycle/#beforeleaveevent[Vaadin's BeforeLeaveEvent]