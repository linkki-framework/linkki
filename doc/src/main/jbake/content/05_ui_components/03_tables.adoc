:jbake-title: Tables
:jbake-type: section
:jbake-status: published

:source-dir-binding: ../../../../../../samples/binding/src/main/java
:source-dir-dynamic: ../../../../../../samples/dynamic-fields/src/main/java
:source-dir-treetable: ../../../../../../samples/tree-table/src/main/java

:images-folder-name: 05_ui_components

[[ui-tables]]
=== Tables

The basics of table creation were already mentioned in the chapter <<binding-table, binding of a table>>. This section details the <<ui-row-pmo,definition of table structure>>, the <<ui-container-pmo, `ContainerPmo<T>`>>, the <<ui-simple-item-supplier, `SimpleItemSupplier<PMO, MO>`>> and the <<ui-table-footer, `TableFooter`>>.

[[ui-row-pmo]]
==== Definition of the table structure with a row PMO
The structure of the table is defined in a PMO class, whose instances represent rows in the table. Thus, these classes are called "row PMOs".

Row PMO classes are standard PMOs, which do not represent sections and thus shouldn't be annotated with `@UISection`.

Here, the annotation <<ui-element,UI element>> defines the column in the table. A column showing the name of a contact, for instance, can be setup as follows:

[source, java]
----
include::{source-dir-binding}/org/linkki/samples/binding/pmo/ContactRowPmo.java[tags=contactRowPmo-labelBinding]
----

That means every property that was found in the row PMO class provided by the `ContainerPmo` is set up as a column. That means every defined property specifies the setup of the column as well as the concrete field inside the table's cell. Next to all aspects that are provided by `@UITableColumn` it takes the label from the field definition.

IMPORTANT: The properties of a table column are described using the properties in the row PMO. But these properties cannot be bound to any specific row PMO instance (there might be none if the table is empty or many if there are a lot of rows). Hence all bindings are directed to the row PMO class. That also means: If you want to <<nls-properties,translate a column label>> the key is created using the class name of the row PMO.

[[ui-table-column]]
===== @UITableColumn

By design all properties of a PMO are presented in the table. With the annotation `@UITableColumn` additional properties of a table column could be bound.

To modify the column size you could use the properties `width` (in pixels) or `expandRatio`.

NOTE: If both properties are set, `width` has a higher priority than `expandRatio`.

Additionally, with the property `collapsible`, you could specify a `CollapseMode` to let the column be collapsible or initially collapsed.


[[ui-simple-table-pmo]]
==== SimpleTablePmo

Most commonly, the row PMO objects are converted from a list of model objects. In this case, the abstract class `org.linkki.core.ui.table.SimpleTablePmo<MO, ROW>` may be extended. This abstract class defines a constructor that requires the list or the supplier for the list of model objects. Additionally the method `createRow(MO)` needs to be implemented. This method simply takes a model object and creates a row PMO for it. A simple example may look like this:

[source, java]
----
include::{source-dir-binding}/org/linkki/samples/binding/pmo/SimpleContactTablePmo.java[tags=simpleContactTablePmo]
----

The `SimpleTablePmo` is an abstract convenience implementation of the `ContainerPmo`.

[[ui-container-pmo]]
==== ContainerPmo

A `ContainerPmo` is a class that implements the interface `ContainerPmo<T>` and might be annotated with `@UISection` to show the table in a `TableSection`. The main function of a `ContainerPmo` is providing the PMOs to be rendered in the table.

The method `List<T> getItems()` is called by the `TableBinding` to add the elements to the table. It should always return the same instance of `List<T>` as long as the items do not change. The <<ui-simple-item-supplier, `SimpleItemSupplier`>> offers support for that.

By overwriting the default method `int getPageLength()` the number of lines shown can be controlled. By default 15 lines are shown. It is a common tactic to allow tables to 'grow' to a certain size and then limit the number of lines while also enabling the scrolling for the table. If `0` is returned the table grows dynamically with the content, without limit.

[source, java]
----
include::{source-dir-binding}/org/linkki/samples/binding/pmo/ContactTablePmo.java[tags=page-length]
----

The column structure of the table is determined by the <<ui-row-pmo, row PMO>> class, which is returned by the method `Class<? extends T> getItemPmoClass`. In the default implementation the class of the generic parameter `T` is returned. To support extensible tables which are configured with other columns, the method can be overwritten and return a subclass of `T`.

If the table should support the adding of items, the `default` method `Optional<ButtonPmo> getAddItemButtonPmo` must be overwritten. How a `ButtonPmo` is created is described in the chapter <<button-pmo, ButtonPmo>>.

[[ui-simple-item-supplier]]
==== SimpleItemSupplier

The `SimpleItemSupplier<PMO, MO>` is used to only create a new `List<PMO>`, if a row was changed.

The instancing is done with two parameters

* `modelObjectSupplier` of type `Supplier<List<MO>>` is called to access a list of the model objects
* `mo2pmoMapping` of type `Function<MO, PMO>` is called for the creation of a PMO for a model objects

.Example initialising of a SimpleItemSuppliers
[source, java]
----
include::{source-dir-binding}/org/linkki/samples/binding/pmo/ContactTablePmo.java[tags=item-supplier]
----

[[ui-hierarchical-table]]
==== HierarchicalRowPmo

Sometimes, the data in a table should be grouped for presentation, for example when summarizing values over certain categories. In that case, the data represents a tree-like structure with parent-child-relationships between rows. The resulting table will be a Vaadin `TreeTable` which allows collapsing and showing the child-rows of a row.

.Hierarchical table
image::{images}{images-folder-name}/treetable.png[A hierarchical table,align="center"]

This can be realized by using `org.linkki.core.ui.table.HierarchicalRowPmo<PMO>`, row PMOs that contain further rows as children. It is possible to use multiple subclasses for row PMOs, using `HierarchicalRowPmo` only for collapsible rows. To indicate that the table contains hierarchical rows, the <<ui-container-pmo,ContainerPmo>> should return `true` in the method `isHierarchical()`. By default, this method returns `true` if `getItemPmoClass()` returns a class that implements `HierarchicalRowPmo`, which means that all rows are collapsible.

[source, java]
----
include::{source-dir-treetable}/org/linkki/samples/treetable/fixed/pmo/SummarizingPersonRowPmo.java[tags=hierarchical-row-pmo]
----

If the order of the rows might change due to user input, you should use a <<ui-simple-item-supplier,`SimpleItemSupplier`>> as with the <<ui-container-pmo,`ContainerPmo`>> to avoid recreating the PMOs for unchanged rows.

[source, java]
----
include::{source-dir-treetable}/org/linkki/samples/treetable/dynamic/pmo/CategoryRowPmo.java[tags=hierarchical-row-pmo-with-simple-item-supplier]
----


[[ui-table-footer]]
==== TableFooterPmo

By overwriting the `default` method `getFooterPmo()` a footer row is generated. The implementation of the interface `TableFooterPmo` must implement the method `getFooterText(String column)`.

The parameter `column` is the ID of the column for which the text should be displayed. An example for this would be a sum of all items from a column.

```java
include::{source-dir-dynamic}/org/linkki/samples/dynamicfield/pmo/CarTablePmo.java[tags=table-footer]
```

[[button-pmo]]
==== ButtonPmo
Currently the <<ui-container-pmo, `ContainerPmo`>> provides a method `getAddItemButtonPmo()`, by which a plus button can be added besides the name of the table. This part of the API is being refactored in the issue LIN-128.
